第6章 面向对象的程序设计

本章内容
・理解对象属性
・理解并创建对象
・理解继承

ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。

6.1 理解对象
创建自定义对象可以通过创建一个Object的实例，或者更常用的使用对象字面量。

6.1.1 属性类型
ECMA-262第5版在定义只有内部才用的特性时，描述了属性的各种特征。ECMA-262定义这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不
能直接访问它们。为了表示特性时内部值，该规范将它们放在了两对儿方括号中，例如[[Enumerable]]。
ECMAScript中有两种属性：数据属性和访问器属性。

1.数据属性
数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。
・[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为true
・[[Enumerable]]：表示能否通过for-in循环返回属性。默认为true
・[[Writable]]：表示能否修改属性的值。默认为true
・[[Value]]：包含这个属性的数据值。从这里读取，也在这里写入。默认为undefined

要修改属性默认的特性，必须使用ECMAScript5的Object.defindProperty()方法。接收三个参数：属性所在对象、属性的名字和一个描述符对象。
其实描述符对象的属性必须是：configuarable、enumerable、writable和value。设置其中的一个或多个值，可以修改对应的特性值。 
var person = {};
Object.defindProperty(person, "name", {
	writable: false,
	value："Nicholas"
});
alert(person.name);		// "Nicholas"
person.name = "Greg";	
alert(person.name);		// "Nicholas"

可以多次调用Object.defineProperty()方法修改同一个属性，但在把configruable特性设置为false之后就会有限制了。在调用Object.defineProperty()
方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。多数情况下，没有必要利用Object.defineProperty()方法 
提供的这些高级功能

2.访问器属性
访问器属性不包含数据值；它们包含一对儿getter和setter函数(这两个函数不是必须的)。在读取访问器属性时，会调用getter函数，这个函数负责
返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：
・[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。默认为true
・[[Enumerable]]：表示能否通过for-in循环返回属性。默认为true。
・[[Get]]：在读取属性时调用的函数。默认值为undefined
・[[Set]]：在写入属性时调用的函数。默认值为undefined

访问器属性不能直接定义，必须使用Object.defineProperty()来定义，如下：
var book = {
	_year: 2004,
	edition: 1
};

Object.defineProperty(book, "year", {
	get: function() {
		return this._year;
	},
	set: function(newValue) {
		if (newValue > 2004) {
			this._year = newValue;
			this.edition += newValue - 2004;
		}
	}
});
book.year = 2005;
alert(book.edition);	// 2

6.1.2 定义多个属性
ECMAScript5定义了一个Object.defineProperties()方法用来为对象定义多个属性。接收两个对象参数：第一个对象是要添加和修改其属性的对象，
第二个对象的属性与第一个对象中要添加或修改的属性一一对应。例如：
var book = {};
Object.defineProperties(book, {
	_year: {
		value：2004
	},
	edition: {
		value:1
	},
	year: {
		get: function() {
			return this._year;
		}
	},
	set: function(newValue) {
		if (newValue > 2004) {
			this._year = newValue;
			this.edition += newValue - 2004;
		}
	}
});

6.1.3 读取属性的特性
使用ECMAScript5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。接收两个参数：属性所在的对象和要读取其描述符的
属性名称。返回值是一个对象。

6.2 创建对象
使用同一个接口创建很多对象，会产生大量的重复代码。为了解决这个问题，开始使用工厂模式的一种变体。

6.2.1 工厂模式
工厂模式抽象了创建具体对象的过程，在ECMAScript中，通过用函数来封装以特定接口创建对象的细节，例如：
function createPerson(name, age, job) {
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function() {
		alert(this.name);
	};
	return o;
}
var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");

工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)，又一个新模式出现了。

6.2.2 构造函数模式
ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。也可以创建自定义
的构造函数，从而定义自定I对象类型的属性和方法，例如：
function Person(name, age, job) {
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = function() {
		alert(this.name);
	};
}
var person1 = new Person("Nicholas", 29, "Software Enginner");
var person2 = new Person("greg", 27, "Doctor");

Person函数和createPerson()中的不同：
・没有显式地创建对象
・直接将属性和方法赋给了this对象
・没有return语句

要创建Person的实例，必须使用new操作符。会经历下列几个步骤：
(1)创建一个新对象
(2)将构造函数的作用域赋给新对象(因此this就指向了这个新对象)
(3)执行构造函数中的代码(为这个新对象添加属性)
(4)返回新对象

前面两个例子的最后，person1和person2分别保存着Person的一个不同的实例。这个两个对象都有一个constructor(构造函数)属性，该属性指向Person:
alert(person1.constructor == Person);		// true
alert(person2.constructor == Person);		// true
 
对象的constructor属性最初是用来标识对象类型的。但是提到检测对象类型，还是instanceof操作符要更可靠一些。
创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；这正是构造函数模式胜过工厂模式的地方。

1.将构造函数当作函数
构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new
操作符来调用，那它就可以作为构造函数。前面的Person()函数可以通过下列任何一种方式来调用：
//当作构造函数调用
var person = new Person("Nicholas", 29, "Software Enginner");
person.sayName();		// "Nicholas"

//作为普通函数调用
Person("Greg", 27, "Doctor");	//添加到window
window.sayName();		// "Greg"

//在另一个对象的作用域中调用
var o = new Object();
Person.call(o, "Kristen", 25, "Nurse");
o.sayName();		//"Kristen"

2.构造函数的问题
使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。如前面person1和person2中都有一个sayName()方法，但是这两个方法不是
同一个Function的实例。
alert(person1.sayName == person2.sayName);		// false
然而创建两个完成同样任务的Function实例的确是没必要的，况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此可以像
下面这样，通过把函数定义转移到构造函数外部来解决问题：
function Person(name, age, job) {
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = sayName;
}
function sayName() {
	alert(this.name);
}

这个例子把sayName()函数定义转移到了构造函数的外部，而在构造函数内部，将sayName属性设置成等于全局的sayName函数。这样一来，由于sayName
包含的是一个指向函数的指针，因此person1和person2对象就共享了在全局作用域中定义的同一个sayName()函数。这样做就解决了两个函数做同一件事。
但是新问题来了：在全局作用域中定义的函数实际上只能被某个对象调用，有点浪费。更严重的是，如果对象需要定义很多方法，那么就要定义很多
全局函数，于是这个自定义的引用类型就丝毫没有封装性可言了。
以上的新问题都可以通过原型模式来解决。

6.2.3 原型模式
我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享
的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有
对象实例共享它所包含的属性和方法，如下：
function Person() {
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
	alert(this.name);
};

1.理解原型对象
无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，
所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。拿前面的例子来说，
person1.prototype.constructor指向Person。通过这个构造函数，我们还可以继续为原型对象添加其他属性和方法。
创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性。
当调用构造函数创建一个新实例后，该实例的内部将包含一个指针(内部属性)，指向构造函数的原型对象。ECMA-262第5版中管这个指针叫做[[Prototype]]。
即Person.prototype指向了Person的原型对象，而Person.prototype.constructor又指回了Person。实例person1和person2都包含一个内部属性
[[Prototype]]，指向Person.prototype。
虽然在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系：
Person.prototype.isPrototypeOf(person1);	// true 

ECMAScript5新增了一个新方法，叫Object.getPrototypeOf()，返回[[Prototype]]的值
Object.getPrototypeOf(person1) == Person.prototype;		// true

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中没有找到，则
继续搜索指针指向的原型对象。
虽然可以通过对象实例访问保存在原型中的值，但不能通过对象实例重写原型中的值，如果在实例中添加了一个属性，与实例原型中的属性同名，则
该实例中新添加的属性将会屏蔽原型中的那个属性。不过通过delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。








