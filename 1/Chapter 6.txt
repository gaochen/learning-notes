第6章 面向对象的程序设计

本章内容
・理解对象属性
・理解并创建对象
・理解继承

ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。

6.1 理解对象
创建自定义对象可以通过创建一个Object的实例，或者更常用的使用对象字面量。

6.1.1 属性类型
ECMA-262第5版在定义只有内部才用的特性时，描述了属性的各种特征。ECMA-262定义这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不
能直接访问它们。为了表示特性时内部值，该规范将它们放在了两对儿方括号中，例如[[Enumerable]]。
ECMAScript中有两种属性：数据属性和访问器属性。

1.数据属性
数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。
・[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为true
・[[Enumerable]]：表示能否通过for-in循环返回属性。默认为true
・[[Writable]]：表示能否修改属性的值。默认为true
・[[Value]]：包含这个属性的数据值。从这里读取，也在这里写入。默认为undefined

要修改属性默认的特性，必须使用ECMAScript5的Object.defindProperty()方法。接收三个参数：属性所在对象、属性的名字和一个描述符对象。
其实描述符对象的属性必须是：configuarable、enumerable、writable和value。设置其中的一个或多个值，可以修改对应的特性值。 
var person = {};
Object.defindProperty(person, "name", {
	writable: false,
	value："Nicholas"
});
alert(person.name);		// "Nicholas"
person.name = "Greg";	
alert(person.name);		// "Nicholas"

可以多次调用Object.defineProperty()方法修改同一个属性，但在把configruable特性设置为false之后就会有限制了。在调用Object.defineProperty()
方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。多数情况下，没有必要利用Object.defineProperty()方法 
提供的这些高级功能

2.访问器属性
访问器属性不包含数据值；它们包含一对儿getter和setter函数(这两个函数不是必须的)。在读取访问器属性时，会调用getter函数，这个函数负责
返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：
・[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。默认为true
・[[Enumerable]]：表示能否通过for-in循环返回属性。默认为true。
・[[Get]]：在读取属性时调用的函数。默认值为undefined
・[[Set]]：在写入属性时调用的函数。默认值为undefined

访问器属性不能直接定义，必须使用Object.defineProperty()来定义，如下：
var book = {
	_year: 2004,
	edition: 1
};

Object.defineProperty(book, "year", {
	get: function() {
		return this._year;
	},
	set: function(newValue) {
		if (newValue > 2004) {
			this._year = newValue;
			this.edition += newValue - 2004;
		}
	}
});
book.year = 2005;
alert(book.edition);	// 2

6.1.2 定义多个属性
ECMAScript5定义了一个Object.defineProperties()方法用来为对象定义多个属性。接收两个对象参数：第一个对象是要添加和修改其属性的对象，
第二个对象的属性与第一个对象中要添加或修改的属性一一对应。例如：
var book = {};
Object.defineProperties(book, {
	_year: {
		value：2004
	},
	edition: {
		value:1
	},
	year: {
		get: function() {
			return this._year;
		}
	},
	set: function(newValue) {
		if (newValue > 2004) {
			this._year = newValue;
			this.edition += newValue - 2004;
		}
	}
});

6.1.3 读取属性的特性
使用ECMAScript5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。接收两个参数：属性所在的对象和要读取其描述符的
属性名称。返回值是一个对象。

6.2 创建对象
使用同一个接口创建很多对象，会产生大量的重复代码。为了解决这个问题，开始使用工厂模式的一种变体。

6.2.1 工厂模式
工厂模式抽象了创建具体对象的过程，在ECMAScript中，通过用函数来封装以特定接口创建对象的细节，例如：
function createPerson(name, age, job) {
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function() {
		alert(this.name);
	};
	return o;
}
var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");

工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)，又一个新模式出现了。

6.2.2 构造函数模式
ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。也可以创建自定义
的构造函数，从而定义自定I对象类型的属性和方法，例如：
function Person(name, age, job) {
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = function() {
		alert(this.name);
	};
}
var person1 = new Person("Nicholas", 29, "Software Enginner");
var person2 = new Person("greg", 27, "Doctor");

Person函数和createPerson()中的不同：
・没有显式地创建对象
・直接将属性和方法赋给了this对象
・没有return语句

要创建Person的实例，必须使用new操作符。会经历下列几个步骤：
(1)创建一个新对象
(2)将构造函数的作用域赋给新对象(因此this就指向了这个新对象)
(3)执行构造函数中的代码(为这个新对象添加属性)
(4)返回新对象

前面两个例子的最后，person1和person2分别保存着Person的一个不同的实例。这个两个对象都有一个constructor(构造函数)属性，该属性指向Person:
alert(person1.constructor == Person);		// true
alert(person2.constructor == Person);		// true
 
对象的constructor属性最初是用来标识对象类型的。但是提到检测对象类型，还是instanceof操作符要更可靠一些。
创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；这正是构造函数模式胜过工厂模式的地方。

1.将构造函数当作函数
构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new
操作符来调用，那它就可以作为构造函数。前面的Person()函数可以通过下列任何一种方式来调用：
//当作构造函数调用
var person = new Person("Nicholas", 29, "Software Enginner");
person.sayName();		// "Nicholas"

//作为普通函数调用
Person("Greg", 27, "Doctor");	//添加到window
window.sayName();		// "Greg"

//在另一个对象的作用域中调用
var o = new Object();
Person.call(o, "Kristen", 25, "Nurse");
o.sayName();		//"Kristen"

2.构造函数的问题
使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。如前面person1和person2中都有一个sayName()方法，但是这两个方法不是
同一个Function的实例。
alert(person1.sayName == person2.sayName);		// false
然而创建两个完成同样任务的Function实例的确是没必要的，况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此可以像
下面这样，通过把函数定义转移到构造函数外部来解决问题：
function Person(name, age, job) {
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = sayName;
}
function sayName() {
	alert(this.name);
}

这个例子把sayName()函数定义转移到了构造函数的外部，而在构造函数内部，将sayName属性设置成等于全局的sayName函数。这样一来，由于sayName
包含的是一个指向函数的指针，因此person1和person2对象就共享了在全局作用域中定义的同一个sayName()函数。这样做就解决了两个函数做同一件事。
但是新问题来了：在全局作用域中定义的函数实际上只能被某个对象调用，有点浪费。更严重的是，如果对象需要定义很多方法，那么就要定义很多
全局函数，于是这个自定义的引用类型就丝毫没有封装性可言了。
以上的新问题都可以通过原型模式来解决。

6.2.3 原型模式
我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享
的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有
对象实例共享它所包含的属性和方法，如下：
function Person() {
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
	alert(this.name);
};

1.理解原型对象
无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，
所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。拿前面的例子来说，
person1.prototype.constructor指向Person。通过这个构造函数，我们还可以继续为原型对象添加其他属性和方法。
创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性。
当调用构造函数创建一个新实例后，该实例的内部将包含一个指针(内部属性)，指向构造函数的原型对象。ECMA-262第5版中管这个指针叫做[[Prototype]]。
即Person.prototype指向了Person的原型对象，而Person.prototype.constructor又指回了Person。实例person1和person2都包含一个内部属性
[[Prototype]]，指向Person.prototype。
虽然在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系：
Person.prototype.isPrototypeOf(person1);	// true 

ECMAScript5新增了一个新方法，叫Object.getPrototypeOf()，返回[[Prototype]]的值
Object.getPrototypeOf(person1) == Person.prototype;		// true

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中没有找到，则
继续搜索指针指向的原型对象。
虽然可以通过对象实例访问保存在原型中的值，但不能通过对象实例重写原型中的值，如果在实例中添加了一个属性，与实例原型中的属性同名，则
该实例中新添加的属性将会屏蔽原型中的那个属性。不过通过delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。

使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法只在给定属性存在于对象实例中时，才会返回true.

2.原型与in操作符
有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于
实例中还是原型中，例如：
function Person() {
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
	alert(this.name);
};
var person1 = new Person();
var person2 = new Person();

alert(person1.hasOwnProperty("name"));		// false
alert("name" in person1);		// true

同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在原型中，如下：
function hasPrototypeProperty(object, name) {
	return !object.hasOwnProperty(name) && (name in object);
}

在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)属性，其中既包括存在于实例中的属性，也包括存在于原型中的
属性。屏蔽了原型中不可枚举属性的实例属性也会在for-in循环中返回
要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性
的字符串数组，例如：
function Person() {
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
	alert(this.name);
};
var keys = Object.keys(Person.prototype);
alert(keys);	// "name,age,job,sayName"
var p1 = new Person();
p1.name = "Rob";
p1.age = 31;
var p1keys = Object.keys(p1);
alert(p1keys);		//"name,age" 只包括实例属性

如果想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法：
var keys = Object.getOwnPropertyNames(Person.prototype);
alert(keys);		// "constructor,name,age,job,sayName"

这两个方法都可以用来替代for-in循环。支持这两个方法的浏览器有IE9+及其他主流浏览器

3.更简单的原型语法
用对象字面量来重写整个原型对象：
function Person() {
}
Person.prototype = {
	name : "Nicholas",
	age : 29,
	job : "Software Engineer",
	sayName : function() {
		alert(this.name);
	}
};
上面的代码，等于是将Person.prototype重写了，所以此时constructor属性不再指向Person了，此时instanceof操作符还能返回正确的结果，但是
constructor已经无法确定对象的类型了，如下：
var friend = new Person();
alert(friend instanceof Object);		// true
alert(friend instanceof Person);		// true
alert(friend.constructor == Person);	// false
alert(friend.constructor == Object);	// true

如果constructor很重要，可以在用对象字面量重写整个原型对象时，显示的设置constructor的值。
但是显示的重设constructor属性会导致它的[[Enumerable]]特性被设置为true。而默认情况下，原生的constructor属性时不可枚举的。可以使用
ECMAScript5的Object.defineProperty()方法：
Object.defindProperty(Person.prototype, "constructor", {
	enumerable: false,
	value: Person
})

4.原型的动态性
例1：
var friend = new Person();
Person.prototype.sayHi = function() {
	alert("hi");
};
friend.sayHi();		// "hi" 
在例1中，先创建实例，然后在Person.prototype中添加一个方法，此时person实例仍然可以访问这个新方法。
然而如果是重写整个原型对象，那么情况就不一样了，例2:
function Person() {
}
var friend = new Person();
Person.prototype = {
	constructor: Person,
	name : "Nicholas",
	age : 29,
	job : "Software Engineer",
	sayName : function() {
		alert(this.name);
	}
};
friend.sayName();	//error
在例2中，实例调用原型中的属性出错，这是因为重写对象切断了现有原型与任何之前已经存在的对象实例之间的联系

5.原生对象的原型
原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型(Object、Array、String等等)
都在其构造函数的原型上定义了方法。例如，在Array.prototype中可以找到sort()方法，在String.prototype中可以找到substring()方法。
通过原生的原型也可以定义新方法，例如给基本包装类型String添加一个startsWith()方法：
String.prototype.startsWith = function(text) {
	return this.indexOf(text) == 0;
};

6.原型对象的问题
小问题是所有实例在默认情况下都将取得相同的属性值。
大问题是原型中所有属性都是被很所实例共享的，如果是引用类型值的属性，就会出问题，例如：
function Person() {
}
Person.prototype = {
	constructor: Person,
	name : "Nicholas",
	age : 29,
	friends : ["Shelby", "Court"],
	job : "Software Engineer",
	sayName : function() {
		alert(this.name);
	}
};

var person1 = new Person();
var person2 = new Person();

person1.friends.push("Van");

alert(person1.friends);		// "Shelby,Court,Van"
alert(person2.friends);		// "Shelby,Court,Van"
alert(person1.friends === person2.friends);		// true
可见，person2也共享了person1的修改，所以一般不会单独使用原型模式

6.2.4 组合使用构造函数模式和原型模式
构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。
function Person(name, age, job) {
	this.name = name;
	this.age = age;
	this.job = job;
	this.friends = ["Shelby", "Court"];
}
Person.prototype = {
	constructor: Person,
	sayName: function() {
		alert(this.name);
	}
}

6.2.5 动态原型模式
原理：将所有信息都封装在构造函数中，仅在必要情况下初始化原型，即通过检查某个应该存在的方法是否有效，来觉得是否需要初始化原型：
function Person(name, age, job) {
	//属性
	this.name = name;
	this.age = age;
	this.job = job;
	//方法
	if (typeof this.sayName != "function") {
		//动态添加
		Person.prototype.sayName = function() {
			alert(this.name);
		}
	}
}

6.2.6 寄生构造函数模式
基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。例如：
function Person(name, age, job) {
	var o = new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function() {
		alert(this.name);
	};
	return o;
}
var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName();	//"Nicholas"

6.2.7 稳妥构造函数模式
稳妥构造函数特点：
・新创建对象的实例方法不引用this
・不使用new操作符调用构造函数
function Person(name, age, job) {
	//创建要返回的对象
	var o = new Object();
	
	//可以在这里定义私有变量和函数
	o.sayName = function() {
		alert(name);
	};
	
	//返回对象
	return o;
}
注意，在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。
var friend = Person("Nicholas", 29, "Software Engineer");
friend.sayName();	// "Nicholas"
变量friend中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方法可以访问其数据成员

6.3 继承
许多OO语言都支持两种继承：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法。ECMAScript只支持实现继承，而且实现
继承主要是依靠原型链来实现的。

6.3.1 原型链
ECMAScript引用了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
回顾构造函数、原型

