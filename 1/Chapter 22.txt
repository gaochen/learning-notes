第21章 高级技巧

本章内容
・使用高级函数
・防篡改对象
・Yielding Timers

22.1 高级函数
22.1.1 安全的类型检测
JavaScript内置的类型检测机制并非安全可靠。比如typeof操作符，它有一些无法预知的行为，经常导致检测数据类型时得到不靠谱的结果。比如在
Safari(直至第4版)在对正则表达式应用typeof操作符时会返回"function"。
instanceof操作符如果检测其他全局作用域(像一个页面包含多个frame)的对象时，将返回false。
解决上述问题的方法都一样，即调用Object原生的toString()方法，会返回一个[object NativeConstructorName]格式的字符串。每个类在内部都有
一个[[Class]]属性，这个属性中就指定了上述字符串中的构造函数名，例如：
//这里value是一个数组
alert(Object.prototype.toString.call(value));	//"[object Array]"

由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值。利用这一点，可以创建如下函数：
function isArray(value) {
	return Object.prototype.toString.call(value) ==  "[object Array]";
}

检测原生的JSON对象：
var isNativeJSON = window.JSON && Object.prototype.toString.call(JSON) == "[object JSON]";

22.1.2 作用域安全的构造函数
当不使用new方法调用构造函数，而是直接构造函数时，this会被映射到全局对象window上，导致错误对象属性的以外增加。这个问题的解决方法就是
创建一个作用域安全的构造函数：
function Person(name, age, job) {
	if (this instanceof Person) {
		this.name = name;
		this.age = age;
		this.job =job;
	}
	else {
		return new Person(name, age, job)
	}
}
这种模式下的继承一定要使用原型链。

22.1.3 惰性载入函数
惰性载入表示函数执行的分支仅会发生一次。有两种实现惰性载入的方式，第一种就是在函数被调用时再处理函数。在第一次调用的过程中，该函数
会被覆盖为另外一个按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行的分支了。
第二种实现惰性载入的方式是在声明函数时就指定适当的函数。这样，第一次调用函数时就不会损失性能了，而在代码首次加载时会损失一点性能。

22.1.4 函数绑定
 函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。该技巧常常和回调函数与事件处理程序一起使用，以便在将函数
 作为变量传递的同时保留代码执行环境。
 很多JavaScript库实现了一个可以将函数绑定到指定环境的函数。这个函数一般都叫bind()。
 一个简单的bind()函数接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并且将所有参数原封不动传递过去。语法如下；
 function bind(fn, context) {
	return function() {
		return fn.apply(context, arguments);
	}
 } 
 
ES5为所有函数定义了一个原生的bind()方法。

22.1.5 函数柯里化
与函数绑定紧密相关的主题是函数柯里化(function currying)，它用于创建已经设置好了一个或多个参数的函数。函数柯里化的基本方法和函数绑定
是一样的：使用一个闭包返回一个函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数。 例如：
function add(num1, num2) {
	return num1 + num2;
}
function curriedAdd(num2) {
	return add(5, num2);
}
alert(add(2, 3));		// 5
alert(curriedAdd(3));	// 8

柯里化函数通常由以下步骤动态创建：调用另一个函数并未它传入要柯里化的函数和必要参数。下面是创建柯里化函数的通用方式：
function curry(fn) {
	var args = Array.prototype.slice.call(arguments, 1);
	return function() {
		var innerArgs = Array.prototype.slice.call(arguments);
		var finalArgs = args.concat(innerArgs);
		return fn.apply(null, finalArgs);
	};
}

curry()函数的主要工作就是将被返回函数的参数进行排序。curry()的第一个参数是要进行柯里化的函数，其他参数是要传入的值。为了获取第一个
参数之后的所有参数，在arguments对象上调用了slice()方法，并传入参数1表示被返回的数据包含从第二个参数开始的所有参数。然后args数组包含
了来自外部函数的参数。在内部函数中，创建了innerArgs数组用来存放所有传入的参数。有了存放来自外部函数和内部函数的参数数组后，就可以
使用concat()方法将它们组合为finalArgs，然后使用apply()将结果传递给该函数。注意这个函数并没有考虑到执行环境，所有调用apply()时第一
个参数是null。应用如下：
function add(num1, num2) {
	return num1 + num2;
}

var curriedAdd = curry(add, 5);
alert(curriedAdd(3));		// 8

函数柯里化还常常作为函数绑定的一部分包含在其中，构造出更为复杂的bind()函数，例如：
function bind(fn, context) {
	var args = Array.prototype.slice.call(arguments, 2);
	return function() {
		var innerArgs = Array.prototype.slice.call(arguments);
		var finalArgs = args.concat(innerArgs);
		return fn.apply(context, finalArgs);
	};
}

当想除了event对象再额外给事件处理程序传递参数时，这非常有用，例如：
var handler = {
	message: "Event handler",
	handleClick: function(name, event) {
		alert(this.message + ":" + name + ":" + event.type);
	}
};

var btn = document.getElementById("my-btn");
EventUtil.addHandler(btn, "click", bind(handler.handleClick, handler, "my-btn"));

ES5提供的bind()函数也支持函数柯里化，使用如下：
EventUtil.addHandler(btn, "click", handler.handleClick.bind(handler, "my-btn"));

22.2 防篡改对象
一旦把对象定义为防篡改，就无法撤销了。
22.1 不可扩展对象
默认情况下，所有对象都是可扩展的，也就是说在任何时候都可以给对象添加属性和方法。
Object.preventExtensions()方法可以使得对象不能再被添加属性和方法。但是对象原有的成员不受影响，仍然可以删除或者修改。
另外，可以使用Object.isExtensible()方法可以确定对象是否可以扩展。

22.2.2 密封的对象
ES5为对象定义的第二个保护级别是密封对象(sealed object)。密封对象不可扩展，而且已有成员的[[Configurable]]特性将被设置为false。这就
意味着不能删除属性和方法，因为不能使用Object.defineProperty()把数据属性修改为访问器属性，或者相反。属性值是可以修改的。
要密封对象，可以使用Object.seal()方法。
var person = {name: "Nicholas"};
Object.seal(person);

person.age = 29;
alert(person.age);		// undefined

delete person.name;
alert(person.name);		// Nicholas

使用Object.isSealed()方法可以确定对象是否被密封了。因为密封对象不可扩展，所有用Object.isExtensible()检测密封的对象也会返回false。

22.2.3 冻结的对象
最严格的防篡改级别是冻结对象(frozen object)。冻结的对象既不可扩展，又是密封的，而且对象数据属性的[[Writable]]特性会被设置为false。
如果定义[[Set]]函数，访问器属性仍然是可写的。ES定义的Object.frozen()方法可以用来冻结对象。
同样，也有一个Object.isFrozen()方法用于检测冻结对象。因为冻结对象既是密封的又是不可扩展的，所有用Object.isExtensible()和Object.isSealed()
检测冻结对象将分别返回false和true。
对JavaScript库的作者而言，冻结对象是很有用的。冻结主要的库对象能够防止库中的核心对象被意外的修改。

22.3 高级定时器