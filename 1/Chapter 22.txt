第21章 高级技巧

本章内容
・使用高级函数
・防篡改对象
・Yielding Timers

22.1 高级函数
22.1.1 安全的类型检测
JavaScript内置的类型检测机制并非安全可靠。比如typeof操作符，它有一些无法预知的行为，经常导致检测数据类型时得到不靠谱的结果。比如在
Safari(直至第4版)在对正则表达式应用typeof操作符时会返回"function"。
instanceof操作符如果检测其他全局作用域(像一个页面包含多个frame)的对象时，将返回false。
解决上述问题的方法都一样，即调用Object原生的toString()方法，会返回一个[object NativeConstructorName]格式的字符串。每个类在内部都有
一个[[Class]]属性，这个属性中就指定了上述字符串中的构造函数名，例如：
//这里value是一个数组
alert(Object.prototype.toString.call(value));	//"[object Array]"

由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值。利用这一点，可以创建如下函数：
function isArray(value) {
	return Object.prototype.toString.call(value) ==  "[object Array]";
}

检测原生的JSON对象：
var isNativeJSON = window.JSON && Object.prototype.toString.call(JSON) == "[object JSON]";

22.1.2 作用域安全的构造函数
当不使用new方法调用构造函数，而是直接构造函数时，this会被映射到全局对象window上，导致错误对象属性的以外增加。这个问题的解决方法就是
创建一个作用域安全的构造函数：
function Person(name, age, job) {
	if (this instanceof Person) {
		this.name = name;
		this.age = age;
		this.job =job;
	}
	else {
		return new Person(name, age, job)
	}
}
这种模式下的继承一定要使用原型链。

22.1.3 惰性载入函数
惰性载入表示函数执行的分支仅会发生一次。有两种实现惰性载入的方式，第一种就是在函数被调用时再处理函数。在第一次调用的过程中，该函数
会被覆盖为另外一个按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行的分支了。
第二种实现惰性载入的方式是在声明函数时就指定适当的函数。这样，第一次调用函数时就不会损失性能了，而在代码首次加载时会损失一点性能。

22.1.4 函数绑定
 函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。该技巧常常和回调函数与事件处理程序一起使用，以便在将函数
 作为变量传递的同时保留代码执行环境。
 很多JavaScript库实现了一个可以将函数绑定到指定环境的函数。这个函数一般都叫bind()。
 一个简单的bind()函数接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并且将所有参数原封不动传递过去。语法如下；
 function bind(fn, context) {
	return function() {
		return fn.apply(context, arguments);
	}
 }